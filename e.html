<!DOCTYPE html>
<html lang="vi-VN">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link id="favicon" rel="icon" type="image/x-icon" href="/assets/dharma-wheel.png">
<style type="text/css">
  body, div, p, a { font-family: Arial, Helvetica, sans-serif; font-size: 18px; }

  .header { position: fixed; left: 0; bottom: 0; width: 100%; background-color: hsla(89, 43%, 51%, 0.5); }

  .header audio#audioPlayer { width: 0%; float: left; height: 25px; }

  .header a, #currentTime, #downloadButton { width: 14%; color: blue; background-color: #ccc; border-width: 1px; border-style: solid; padding: 0.5em 0em; float: right; margin-right: 5px; text-align: center; text-decoration: none; }

  #downloadButton { position: fixed; top: 4px; right: 0; width: 3em; }

  div { margin-top: 0.5em; padding: .3em; color: #888; }
  
  p { padding-top: 0.5em; padding-bottom: 0.5em; margin: 0.1em; 
      border-style: dotted; border-width: 1px; }
  
  p.edited { color: #000; }
  
  p:focus { border: 0px; border-style: none; color: #112699; }
  
  i { font-size: 12pt; color: #aaa; }
</style>
 </head>
<body>
  <div class="header">
    <audio controls id="audioPlayer"></audio>

    <a href="" onclick="event.code='ControlLeft';handleKeyPress(event);event.preventDefault();
      document.getElementById(currSubIndex).focus();" style="float:left;">=></a>
    <a href="" onclick="event.code='OSRight';handleKeyPress(event);event.preventDefault();
      document.getElementById(currSubIndex).focus();" style="float:left;"><<</a>
    <a href="" onclick="event.code='AltRight';handleKeyPress(event);event.preventDefault();
      document.getElementById(currSubIndex).focus();" style="float:left;">>></a>

    <a href="" onclick="event.code='Enter'; handleKeyPress(event);"style="margin-right:15px;">Ent</a>
    <a href="" onclick="event.code='Slash'; event.key='/';handleKeyPress(event);
      document.getElementById(currSubIndex).focus();">/</a>
    <a href="" id="playPauseBtn" onclick="ap.paused ? ap.play() : ap.pause();
      event.preventDefault(); document.getElementById(currSubIndex).focus();">></a>
  </div>
  <a href="?" id="downloadButton" style="float:left;">Save</a>
  <a id="lrcDownload"></a>
</body>

<script src="assets/localforage.min.js"></script>
<script src="assets/words_secs.js"></script>
<script>
document.getElementById("downloadButton").addEventListener("click", function(e) {
  e.preventDefault();
  z();
});

var phapname = location.search.replace("?", "")
console.log('phapname', phapname);
// var store = localforage.createInstance({ name: phapname });
function finalKey(key) {
  return phapname + "_" + key; 
}
async function load(key) {
  return await localforage.getItem(finalKey(key));
}
function save(key, value) {
  localforage.setItem(finalKey(key), value);
}


var ap = document.getElementById("audioPlayer");
ap.innerHTML = `<source src="${phapname}.mp3"/><source src="${phapname}.ogg"/>`
ap.ontimeupdate = function() {
  var seconds = ap.currentTime;
  var minutes = Math.floor(seconds / 60);
  seconds = Math.round(seconds - minutes * 60);
  document.getElementById('playPauseBtn').innerHTML = 
    `${minutes}:${seconds<=9?'0':''}${seconds}`;
};

var subsCount, currSubIndex, currKey;
var expanding = false;
loadSubsCount().then(function () {
  if (!isNaN(subsCount) && subsCount > 0 && !expanding) {
    console.log("Use cached data to gen subs");
    genSubs();

  } else {
    save('phapname', phapname);

    var xmlhttp = new XMLHttpRequest();
    xmlhttp.onreadystatechange = function () {
      if (this.readyState == 4 && this.status == 200) {
        txt = this.responseText;
        initSubs(txt).then(genSubs);
      }
    };
    xmlhttp.open("GET", phapname+".lab", true);
    xmlhttp.send();
  }
});


function saveSubsCount(value) {
  subsCount = value;
  save('subsCount', subsCount);
}
async function loadSubsCount() {
  return subsCount = parseInt(await load('subsCount'));
}
function markEditedIndex(i) {
  save(`edited${i}`, 'true');
}
async function isEditedIndex(i) {
  return await load(`edited${i}`) == 'true';
}
function saveTime(i, value) {
  save(`time${i}`, value);
  markEditedIndex(i);
  var el = document.getElementById(i);
  if (el) {
    el.previousSibling.innerHTML = `${i}: ${value}`;
    el.className = 'edited';
  }
}
async function loadTime(i) {
  return parseFloat(await load(`time${i}`));
}

function saveTextIndex(i) {
  saveText(i, document.getElementById(i).innerText);
}
function saveText(i, value) {
  save(`text${i}`, value);
}
async function loadText(i) {
  return await load(`text${i}`);
}
async function saveAll() {
  for (var i = 0; i < subsCount; i++) {
    await saveTextIndex(i);
  }
}
async function z() {
  await saveAll();

  var str = "";
  for (var i = 0; i < subsCount; i++) {
    var timeI = await loadTime(i), timeI1 = await loadTime(i+1);
    if (timeI > timeI1) {
      console.log("ERROR: time of line", i, '> time of line', i + 1);
      // throw 'Timming-order error!';
    }
    str = str + `${timeI} ${await loadText(i)}\n`;
  }
  // console.log(str);
  var a = document.getElementById("lrcDownload");
  var file = new Blob([str], {type: 'text/plain'});
  copyToClipboard(str);
  a.href = URL.createObjectURL(file);
  a.download = phapname.split("/")[1] + '.txt';
  a.target = '_blank';
  a.click();
}

const copyToClipboard = str => {
  const el = document.createElement('textarea');
  el.value = str;
  document.body.appendChild(el);
  el.select();
  document.execCommand('copy');
  document.body.removeChild(el);
};


const IDEAL_LINE_CHARS = 45*5;
const MAX_LINE_CHARS = 60*5;
const MIN_LINE_CHARS = 22*5;

const END_PHRASE_AND_SENT_REGEX = /(\s*(?:[,;:\n\\\.\?\!]\s*)+)/gm;
const END_SENT_REGEX =            /(\s*(?:[\n\\\.\?\!]\s*)+)/gm;
async function initSubs(txt) {
  var sents = [], sent;
  var splits = txt.split(END_SENT_REGEX); splits.push("");
  
  while (splits.length >= 2) {
    sent = splits.shift() + splits.shift();
    sent = sent.replace(/\n/gm,'\\').replace(/\s+/gm," ");
    sent = sent.replace(/^\s+/m,"").replace(/\s+$/m,"");
    sents.push(sent);
  }

  
  splits = []; var n, i, m, phrases, k, s;
  
  for (n=sents.length, i=0; i < n; i++) {
  
    m = sents[i].length;
    console.log('Sent',i,'length is',m);

    if (m > IDEAL_LINE_CHARS) {
      phrases = sents[i].split(END_PHRASE_AND_SENT_REGEX);
      phrases.push("");
      sent = "", k = 0;
      while (k < MIN_LINE_CHARS && phrases.length >= 2) {
        sent = sent + (s = phrases.shift()) + phrases.shift();
        k = k + s.length;
      }

      splits.push(sent);
      console.log('splited to:', sent);

      if (phrases.length > 0) {
        sents[i] = phrases.join("");
        console.log('... remain is:', sents[i]);
        i--;
      }

    } else 
    if ( m < MIN_LINE_CHARS && i < n-1 
        && m+sents[i+1].length <= MAX_LINE_CHARS ) {

      console.log('merged length', m+sents[i+1].length, '< max length', MAX_LINE_CHARS);
      sents[i+1] = sents[i]+' '+sents[i+1];      
      console.log('... merged to sents[i+1]', sents[i+1]);

    } else if ( m < MIN_LINE_CHARS && i > 0 
        && m+sents[i-1].length <= MAX_LINE_CHARS ) {

      sents[i] = splits.pop()+' '+sents[i];
      splits.push(sents[i]);
      console.log('... merged to sents[i]', sents[i]);
    
    } else {
      
      splits.push(sents[i]);
    }
  } // for

  var n = 0, time;
  if (expanding) do {
      time = await loadTime(++n);
    } while (!isNaN(time) && time > 0);

  splits.push("./.");
  for (i = 0; i < splits.length; i++) {
    saveTime(n, 0);
    saveText(n, splits[i]);
    n++;
  }
  saveSubsCount(n);
}

function spellNumber(x) {
  // console.log(`spellNumber "${x}"`)
  var prefix, md, mdd;

  // xxx
  if (md = x.match(/^(\d)(\d\d)$/)) {
    prefix = `${md[1]} trăm`;

    if (md[2] == '00')
      return prefix;

    if (mdd = md[2].match(/^0(\d)$/))
        return `${prefix} lẻ ${mdd[1]}`

    return `${prefix} ${spellNumber(md[2])}`
  }

  // xx
  if (md = x.match(/^(\d)(\d)$/)) {
    if (x == '10') return 'mười'

    // 1x => mười x (11,11,..,19)
    // 2x => 2 x (2x,..,9x)
    prefix = md[1] == '1' ? 'mười' : md[1];

    // x0 => x mươi
    if (md[2] == '0')
      return `${prefix} mươi`

    // x4 => x tư
    if (md[2] == '4')
      return `${prefix} tư`

    // x5 => x năm
    if (md[2] == '5')
      return `${prefix} lăm`

    return `${md[1]} ${md[2]}`
  }

  return x;
}

function spellSpecialWords(txt) {
  var z;
  // e.g: 100 or 100% not end with |
  return txt.replace(/\d+%?(?<!\|)/gi, function (x) {
    z = x;
    // Just return 0-9,10
    if (x.match(/^(\d|10)$/)) { return z; }
   
    if (md = x.match(/^(\d+)%$/))
      return `|${spellNumber(md[1])} phần trăm|${x}|`;
    
    // Default is number
    return `|${spellNumber(x)}|${x}|`;
  });
}

function focusAndScrollIntoViewSubIndex(index) {
  var p = document.getElementById(index);
  p.focus();
  p.scrollIntoView();
}

async function genSubs() {
  await loadSubsCount();
  currSubIndex = -1;
  for (var p, div, time, text, i = 0; i < subsCount; i++) {
    div = document.createElement('div');
    time = await loadTime(i);
    div.innerHTML = `<i>${i}: ${time}</i>`;
    div.onclick = function() { this.children[1].focus(); };
    p = document.createElement('p');
    p.contentEditable = "true";
    p.innerHTML = spellSpecialWords(await loadText(i));
    p.id = i;
    p.className = await isEditedIndex(i) ? 'edited' : '';
    // if p is click then p will get focus
    p.addEventListener("click", playSub);
    p.addEventListener("focus", playAndUpdateSub);
    p.addEventListener("blur", saveCurrentText);
    div.appendChild(p);
    document.body.appendChild(div);

    if (currSubIndex < 0 && time == 0 && (currSubIndex = i-1) >= 0) {
      focusAndScrollIntoViewSubIndex(currSubIndex);
      console.log('currSubIndex', currSubIndex);
    }
  }
  document.body.appendChild(document.createElement('<br>'));
  document.body.appendChild(document.createElement('<br>'));
}


/* - - - - */ 

function saveCurrentText() {
  saveTextIndex(parseInt(this.id));
}

function saveCurrSubIndex(index) {
  save('currSubIndex', currSubIndex = index);
}


async function playSubIndex(index, delta = 0) {
  var time = await loadTime(index);
  if (time != 0 || index == 0) { 
    ap.currentTime = time + delta;
    ap.play();
  }  
}

const defaultSecondsPerWord = 0.3;
var secondsPerWord = defaultSecondsPerWord;
async function estimateSecondsPerWord(index) {
  if (await loadTime(index + 1) > 0) { index++; }

  if (index == 0) { return secondsPerWord; }
  q = await loadText(index - 1);
  b = await loadTime(index - 1);
  e = await loadTime(index);
  if (b == 0 || b >= e) { return secondsPerWord; }

  x = (e - b) / q.split(/\s+/).length;
  secondsPerWord = (x <= 0.36) ? x : secondsPerWord;
  console.log('New secondsPerWord:', secondsPerWord);

  return secondsPerWord;
}

const notWordRegex = /[\s\,\.\<\>\;\:\/\?\|\\\[\]\{\}\`\~\!\@\#\$\%\^\&\*\(\)\_\+\-\=“”…‘’]+/gm
async function getDelta(index) {
  var q = document.getElementById(index).innerText;
  q = q.substr(0, window.getSelection().anchorOffset);
  q = q.toLocaleLowerCase();
  var words = q.split(notWordRegex);
  
  var wordsCount = words.length - 2;
  if (words.pop() == "") wordsCount--;
  // Too short para always return 0 to make it point to the beginning of the sent
  if (wordsCount <= 0) return 0;
  if (words.length > 20) wordsCount -= words.length / 10;
  if (words.length > 40) wordsCount -= words.length / 20;
  var breakCount1 = q.split(END_PHRASE_AND_SENT_REGEX).length - 1;
  var breakCount2 = q.split(END_SENT_REGEX).length - 1;
  wordsCount += breakCount1*0.3 + breakCount2*0.5;
  var delta2 = wordsCount * (await estimateSecondsPerWord(index));

  var delta1 = 0;
  if (words.length > 0) {
    words.forEach(w => delta1 += document.words_secs[w]||defaultSecondsPerWord);
    delta1 += (breakCount1+breakCount2)*defaultSecondsPerWord*0.8;
  }
  
  console.log('index', index, 'words.length', words.length, 'delta1', delta1, 
    'wordsCount', wordsCount, 'delta2', delta2);
  return (delta1 + delta2) / 2;
}

async function playSub() {
  var index = parseInt(this.id);

  if (currSubIndex != index) {
    saveCurrSubIndex(index);
    playSubIndex(currSubIndex);
  }  else { 
    // Click on current sub, will pause audio (to edit text)
    ap.currentTime = (await loadTime(index)) + (await getDelta(index));
    ap.play();
  }
}

function playAndUpdateSub() {
  saveTextIndex(currSubIndex - 1);
  saveTextIndex(currSubIndex);

  if (currKey == 'Enter' || currKey == 'Slash') {  
    saveCurrSubIndex(currSubIndex);
    saveTime(currSubIndex, ap.currentTime);
  } else if ((index = parseInt(this.id)) != currSubIndex) {
    playSubIndex(currSubIndex);
  }
  currKey = null;
}

async function seekCurrTime(delta) {
  var time = await loadTime(currSubIndex) + delta;
  saveTime(currSubIndex, time);
  ap.currentTime = time;
  ap.play();
}

document.addEventListener("keydown", handleKeyPress);

async function handleKeyPress(event) {
  currKey = event.code;
  console.log(`KeyboardEvent: key='${event.key}' | code='${event.code}'`);
  // console.log('currKey', currKey);

  switch(currKey) {
    case 'Slash':
      if (event.key != '/') { return; }
      event.preventDefault();
      playAndUpdateSub();
      break;

    case 'ControlLeft':
      ap.currentTime = await loadTime(currSubIndex);
      ap.play();
      break;

    case 'AltLeft':
      event.preventDefault();
      ap.paused ? ap.play() : ap.pause();
      break;

    case 'Enter':
      event.preventDefault();
      nextSub();
      break;

    case 'Tab':
      event.preventDefault();
      nextSub();
      break;

    case 'AltRight':
      event.preventDefault();
      if (await getDelta(currSubIndex) <= 0) {
        seekCurrTime(0.15);
      } else {
        ap.currentTime += 3;
        ap.play();
      }      
      break;

    case 'OSRight':
      event.preventDefault();
      if (await getDelta(currSubIndex) <= 0) {
        seekCurrTime(-0.15);
      } else {
        ap.currentTime -= 3;
        ap.play();
      }
      break;

    case 'ArrowUp':
      break

    case 'ArrowDown':
      break

    case 'ArrowLeft':
      break

    case 'ArrowRight':
      break

    default:
      if (await loadTime(currSubIndex) != 0) { ap.pause(); }
  }
}

const pasteToCurrentEditableCursor = str => {
  document.execCommand('inserttext', false, str);
};


function nextSub() {
  if (currSubIndex < subsCount - 1) { 
    currSubIndex++;  
    document.getElementById(currSubIndex).focus();
  }
}
</script>
</html>
