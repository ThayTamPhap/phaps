<!DOCTYPE html>
<html lang="vi-VN">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link id="favicon" rel="icon" type="image/x-icon" href="/assets/dharma-wheel.png">
<style type="text/css">
  body, div, p, a { font-family: Arial, Helvetica, sans-serif; font-size: 18px; }

  .header { position: fixed; left: 0; bottom: 0; width: 100%; background-color: hsla(89, 43%, 51%, 0.5); }

  .header audio#audioPlayer { width: 0%; float: left; height: 25px; }

  .header a, #currentTime, #downloadButton { width: 14%; color: blue; background-color: #ccc; border-width: 1px; border-style: solid; padding: 0.5em 0em; float: right; margin-right: 5px; text-align: center; text-decoration: none; }

  #downloadButton { position: fixed; top: 4px; right: 0; width: 3em; }

  div { margin-top: 0.5em; padding: .3em; color: #888; }
  
  p { padding-top: 0.5em; padding-bottom: 0.5em; margin: 0.1em; 
      border-style: dotted; border-width: 1px; }
  
  p.edited { color: #000; }
  
  p:focus { border: 0px; border-style: none; color: #112699; }
  
  i { font-size: 12pt; color: #aaa; }
</style>
 </head>
<body>
  <div class="header">
    <audio controls id="audioPlayer"></audio>

    <a href="" onclick="event.code='ControlLeft';handleKeyPress(event);event.preventDefault();
      document.getElementById(currSubIndex).focus();" style="float:left;">>|</a>
    <a href="" onclick="event.code='OSRight';handleKeyPress(event);event.preventDefault();
      document.getElementById(currSubIndex).focus();" style="float:left;"><<</a>
    <a href="" onclick="event.code='AltRight';handleKeyPress(event);event.preventDefault();
      document.getElementById(currSubIndex).focus();" style="float:left;">>></a>

    <a href="" onclick="event.code='Enter'; handleKeyPress(event);"style="margin-right:15px;">Ent</a>
    <a href="" onclick="event.code='Slash'; event.key='/';handleKeyPress(event);
      document.getElementById(currSubIndex).focus();">/</a>
    <a href="" id="playPauseBtn" onclick="ap.paused ? ap.play() : ap.pause();
      event.preventDefault(); document.getElementById(currSubIndex).focus();">></a>
  </div>
  <a href="?" id="downloadButton" style="float:left;">Save</a>
  <a id="lrcDownload"></a>
</body>

<script src="assets/localforage.min.js"></script>
<script src="assets/words_secs.js"></script>
<script>
document.getElementById("downloadButton").addEventListener("click", function(e) {
  e.preventDefault();
  z();
});

var phapname = location.search.replace("?", "")
console.log('phapname', phapname);
// var store = localforage.createInstance({ name: phapname });
function finalKey(key) {
  return phapname + "_" + key; 
}
async function load(key) {
  return await localforage.getItem(finalKey(key));
}
function save(key, value) {
  localforage.setItem(finalKey(key), value);
}


var ap = document.getElementById("audioPlayer");
ap.innerHTML = `<source src="${phapname}.mp3"/><source src="${phapname}.ogg"/>`
ap.ontimeupdate = function() {
  var seconds = ap.currentTime;
  var minutes = Math.floor(seconds / 60);
  seconds = Math.round(seconds - minutes * 60);
  document.getElementById('playPauseBtn').innerHTML = 
    `${minutes}:${seconds<=9?'0':''}${seconds}`;
};

var subsCount, currSubIndex, currKey;
var expanding = false;
loadSubsCount().then(function () {
  if (!isNaN(subsCount) && subsCount > 0 && !expanding) {
    console.log("Use cached data to gen subs");
    genSubs();

  } else {
    save('phapname', phapname);

    var xmlhttp = new XMLHttpRequest();
    xmlhttp.onreadystatechange = function () {
      if (this.readyState == 4 && this.status == 200) {
        txt = this.responseText;
        initSubs(txt).then(genSubs);
      }
    };
    xmlhttp.open("GET", phapname+".lab", true);
    xmlhttp.send();
  }
});


function saveSubsCount(value) {
  subsCount = value;
  save('subsCount', subsCount);
}
async function loadSubsCount() {
  return subsCount = parseInt(await load('subsCount'));
}
function markEditedIndex(i) {
  save(`edited${i}`, 'true');
}
async function isEditedIndex(i) {
  return await load(`edited${i}`) == 'true';
}
function saveTime(i, value) {
  save(`time${i}`, value);
  markEditedIndex(i);
  var el = document.getElementById(i);
  if (el) {
    el.previousSibling.innerHTML = `${i}: ${secondsToTime(value)}`;
    el.className = 'edited';
  }
}
async function loadTime(i) {
  return parseFloat(await load(`time${i}`));
}

function saveTextIndex(i) {
  saveText(i, document.getElementById(i).innerText);
}
function saveText(i, value) {
  save(`text${i}`, value);
}
async function loadText(i) {
  return await load(`text${i}`);
}
async function saveAll() {
  for (var i = 0; i < subsCount; i++) {
    await saveTextIndex(i);
  }
}
async function z() {
  await saveAll();

  var str = "";
  for (var i = 0; i < subsCount; i++) {
    var timeI = await loadTime(i), timeI1 = await loadTime(i+1);
    if (timeI > timeI1) {
      console.log("ERROR: time of line", i, '> time of line', i + 1);
      // throw 'Timming-order error!';
    }
    str = str + `${timeI} ${await loadText(i)}\n`;
  }
  // console.log(str);
  var a = document.getElementById("lrcDownload");
  var file = new Blob([str], {type: 'text/plain'});
  copyToClipboard(str);
  a.href = URL.createObjectURL(file);
  a.download = phapname.split("/")[1] + '.txt';
  a.target = '_blank';
  a.click();
}

const copyToClipboard = str => {
  const el = document.createElement('textarea');
  el.value = str;
  document.body.appendChild(el);
  el.select();
  document.execCommand('copy');
  document.body.removeChild(el);
};


const IDEAL_LINE_CHARS = 45*5;
const MAX_LINE_CHARS = 60*5;
const MIN_LINE_CHARS = 22*5;

const END_PHRASE_AND_SENT_REGEX = /(\s*(?:[,;:\n\\\.\?\!]\s*)+)/gm;
const END_SENT_REGEX =            /(\s*(?:[\n\\\.\?\!]\s*)+)/gm;
async function initSubs(txt) {
  var sents = [], sent;
  var splits = txt.split(END_SENT_REGEX); splits.push("");
  
  while (splits.length >= 2) {
    sent = splits.shift() + splits.shift();
    sent = sent.replace(/\n/gm,'\\').replace(/\s+/gm," ");
    sent = sent.replace(/^\s+/m,"").replace(/\s+$/m,"");
    sents.push(sent);
  }

  
  splits = []; var n, i, m, phrases, k, s;
  
  for (n=sents.length, i=0; i < n; i++) {
  
    m = sents[i].length;
    console.log('Sent',i,'length is',m);

    if (m > IDEAL_LINE_CHARS) {
      phrases = sents[i].split(END_PHRASE_AND_SENT_REGEX);
      phrases.push("");
      sent = "", k = 0;
      while (k < MIN_LINE_CHARS && phrases.length >= 2) {
        sent = sent + (s = phrases.shift()) + phrases.shift();
        k = k + s.length;
      }

      splits.push(sent);
      console.log('splited to:', sent);

      if (phrases.length > 0) {
        sents[i] = phrases.join("");
        console.log('... remain is:', sents[i]);
        i--;
      }

    } else 
    if ( m < MIN_LINE_CHARS && i < n-1 
        && m+sents[i+1].length <= MAX_LINE_CHARS ) {

      console.log('merged length', m+sents[i+1].length, '< max length', MAX_LINE_CHARS);
      sents[i+1] = sents[i]+' '+sents[i+1];      
      console.log('... merged to sents[i+1]', sents[i+1]);

    } else if ( m < MIN_LINE_CHARS && i > 0 
        && m+sents[i-1].length <= MAX_LINE_CHARS ) {

      sents[i] = splits.pop()+' '+sents[i];
      splits.push(sents[i]);
      console.log('... merged to sents[i]', sents[i]);
    
    } else {
      
      splits.push(sents[i]);
    }
  } // for

  var n = 0, time;
  if (expanding) do {
      time = await loadTime(++n);
    } while (!isNaN(time) && time > 0);

  splits.push("./.");
  for (i = 0; i < splits.length; i++) {
    saveTime(n, 0);
    saveText(n, splits[i]);
    n++;
  }
  saveSubsCount(n);
}

function spellNumber(x) {
  // console.log(`spellNumber "${x}"`)
  var prefix, md, mdd;

  // xxx
  if (md = x.match(/^(\d)(\d\d)$/)) {
    prefix = `${md[1]} trăm`;

    if (md[2] == '00')
      return prefix;

    if (mdd = md[2].match(/^0(\d)$/))
        return `${prefix} lẻ ${mdd[1]}`

    return `${prefix} ${spellNumber(md[2])}`
  }

  // xx
  if (md = x.match(/^(\d)(\d)$/)) {
    if (x == '10') return 'mười'

    // 1x => mười x (11,11,..,19)
    // 2x => 2 x (2x,..,9x)
    prefix = md[1] == '1' ? 'mười' : md[1];

    // x0 => x mươi
    if (md[2] == '0')
      return `${prefix} mươi`

    // x4 => x tư
    if (md[2] == '4')
      return `${prefix} tư`

    // x5 => x năm
    if (md[2] == '5')
      return `${prefix} lăm`

    return `${md[1]} ${md[2]}`
  }

  return x;
}

// https://regexr.com/ => to test regex
const SPECIAL_WORDS_REGEX = /(\d+%?)([^\d%|]|$)/g;
function spellSpecialWords(txt) {
  // e.g: 100 or 100% not end with |
  return txt.replace(SPECIAL_WORDS_REGEX, function (x) {
    var m = x.match(/(\d+%?)([^\d%\|]|$)/);
    // console.log(txt, x, m);
    // Just return 0-9,10
    if (m[1].match(/^(\d|10)$/)) return x;
    
    if (md = m[1].match(/^(\d+)%$/))
      return `|${spellNumber(md[1])} phần trăm|${m[1]}|${m[2]}`;
    
    // Default is number
    return `|${spellNumber(m[1])}|${m[1]}|${m[2]}`;
  });
} /*
spellSpecialWords("100%|") == "100%|"
spellSpecialWords("100%") == "|1 trăm phần trăm|100%|"
spellSpecialWords("10") == "10"
spellSpecialWords("10|") == "10|"
spellSpecialWords("15q") == "|mười lăm|15|q"
*/

function focusAndScrollIntoViewSubIndex(index) {
  var p = document.getElementById(index);
  p.focus();
  p.scrollIntoView();
}

async function genSubs() {
  await loadSubsCount();
  currSubIndex = -1;
  for (var p, div, time, text, i = 0; i < subsCount; i++) {
    div = document.createElement('div');
    time = await loadTime(i);
    div.innerHTML = `<i>[${i}] ${secondsToTime(time)}</i>`;
    p = document.createElement('p');
    p.contentEditable = "true";
    p.innerHTML = spellSpecialWords(await loadText(i));
    p.id = i;
    p.className = await isEditedIndex(i) ? 'edited' : '';
    // if p is click then p will get focus
    p.addEventListener("click", playSub);
    p.addEventListener("focus", playAndUpdateSub);
    p.addEventListener("blur", saveCurrentText);
    div.appendChild(p);
    document.body.appendChild(div);

    if (currSubIndex < 0 && time == 0 && (currSubIndex = i-1) >= 0) {
      focusAndScrollIntoViewSubIndex(currSubIndex);
      console.log('currSubIndex', currSubIndex);
    }
  }
  document.body.appendChild(document.createElement('br'));
  document.body.appendChild(document.createElement('br'));
}


/* - - - - */ 

function saveCurrentText() {
  saveTextIndex(parseInt(this.id));
}

function saveCurrSubIndex(index) {
  save('currSubIndex', currSubIndex = index);
}


async function playSubIndex(index, delta = 0) {
  var time = await loadTime(index);
  if (time != 0 || index == 0) { 
    ap.currentTime = time + delta;
    ap.play();
  }  
}

const defaultSecondsPerWord = 0.3;
var secondsPerWord = defaultSecondsPerWord;
async function estimateSecondsPerWord(index) {
  if (index == 0) { return secondsPerWord; }
  q = await loadText(index - 1);
  b = await loadTime(index - 1);
  e = await loadTime(index);
  if (b == 0 || b >= e) { return secondsPerWord; }

  x = (e - b) / q.split(/\s+/).length;
  secondsPerWord = (x <= 0.36) ? x : secondsPerWord;
  console.log('New secondsPerWord:', secondsPerWord);

  return secondsPerWord;
}

const notWordRegex = /[\s\,\.\<\>\;\:\/\?\|\\\[\]\{\}\`\~\!\@\#\$\%\^\&\*\(\)\_\+\-\=“”…‘’]+/gm

var adjustedDeltas = [];
function resetAdjustedDeltas() {
  adjustedDeltas = [];
}

function adjustDeltas(x) {
  var currPos = getCurrPosStr().length;
  var ad = adjustedDeltas[currPos];
  adjustedDeltas[currPos] = (ad == undefined ? 0 : ad) + x;
  adjustedDeltas = adjustedDeltas.slice(0, currPos + 1);
}

function blinkCurPos(pos) {
  let sel = window.getSelection();  
  var currPos = typeof pos == 'number' ? pos : sel.anchorOffset;
  var currP = document.getElementById(currSubIndex);
  var txt = currP.firstChild.textContent;
  var b = currPos, e = currPos+1, n = txt.length;
  while (txt[b] != ' ' && b > 0) b--; if (b < 0) b = 0;
  while (txt[e] != ' ' && e < n) e++; if (e > n) e = n;
  

  let range = new Range();
  range.setStart(currP.firstChild, b == 0 ? 0 : b+1);
  range.setEnd(currP.firstChild, e);
  sel.removeAllRanges();
  sel.addRange(range);

  let count = 1;
  let interval = window.setInterval(function() {
    if (count % 2 == 0) {
      range.setStart(currP.firstChild, b == 0 ? 0 : b+1);
      range.setEnd(currP.firstChild, e);
      sel.removeAllRanges();
      sel.addRange(range);
    } else {
      sel.collapse(currP.firstChild, currPos);
    }
    if (++count > 3) { clearInterval(interval); }
  }, 80);
}

function getCurrPosStr() {
  var currP = document.getElementById(currSubIndex);
  var currInnerText = currP.innerText;
  lastCurrPos = window.getSelection().anchorOffset;
  return currInnerText.substr(0, lastCurrPos);
}

async function getCurrDelta() {
  var q = getCurrPosStr();
  q = q.toLocaleLowerCase();
  var currPos = q.length;
  var words = q.split(notWordRegex);
  
  var wordsCount = words.length - 2;
  if (words[words.length - 1] == "") { wordsCount--; }
  // Too short string always return 0 to make it point to the beginning of the sent
  if (wordsCount <= 0) return 0;
  if (words.length > 20) wordsCount -= words.length / 10;
  if (words.length > 40) wordsCount -= words.length / 20;
  var breakCount1 = q.split(END_PHRASE_AND_SENT_REGEX).length - 1;
  var breakCount2 = q.split(END_SENT_REGEX).length - 1;
  wordsCount += breakCount1*0.3 + breakCount2*0.5;
  var delta2 = wordsCount * (await estimateSecondsPerWord(currSubIndex));

  var delta1 = 0;
  if (words.length > 0) {
    words.forEach(w => { 
      // console.log("words_secs[", w, "]", document.words_secs[w]);
      return delta1 += document.words_secs[w]||defaultSecondsPerWord; 
    });
    delta1 += (breakCount1+breakCount2)*defaultSecondsPerWord*0.8;
  }
  
  var delta = (delta1 + delta2) / 2;
  var n = adjustedDeltas.length - 1;
  if (n > currPos) n = currPos;
  for (var ad, i = 0; i <= n; i++) { 
    ad = adjustedDeltas[i]
    if (ad != 0 && ad != undefined) {
      delta += ad;
      console.log("adjustedDeltas[",i,"] = ", ad);
    }
  };

  console.log('currSub:', currSubIndex, ', words.length', words.length, 'delta1', delta1, 
    'wordsCount', wordsCount, 'delta2', delta2, 'currPos', currPos, 'adjustedDeltas.length', adjustedDeltas.length, 'delta', delta);

  return delta < 0 ? 0 : delta;
}

async function playCurrPos() {
    ap.currentTime = (await loadTime(currSubIndex)) + (await getCurrDelta());
    ap.play();
}

async function playSub() {
  var index = parseInt(this.id);

  if (currSubIndex != index) {
    // First click on sub
    resetAdjustedDeltas();
    saveCurrSubIndex(index);
    await playSubIndex(currSubIndex);
    blinkCurPos(0);
  }  else { 
    // Click on current sub
    await playCurrPos();
    blinkCurPos();
  }
}

function playAndUpdateSub() {
  if (currSubIndex > 1) saveTextIndex(currSubIndex - 1);
  saveTextIndex(currSubIndex);

  if (currKey == 'Enter' || currKey == 'Slash') {  
    saveCurrSubIndex(currSubIndex);
    saveTime(currSubIndex, ap.currentTime);
  } else if (parseInt(this.id) != currSubIndex) {
    playSubIndex(currSubIndex);
  }
  currKey = null;
}

document.addEventListener("keydown", handleKeyPress);

var lastCurrPos = 0;
function resetTextAndPos() {
    // Reset HTML to plain text to select correct cursor position
    var currP = document.getElementById(currSubIndex);
    var currInnerText = currP.innerText;
    currP.innerHTML = currInnerText;
    
    console.log('currInnerText.length', currInnerText.length, 'lastCurrPos', lastCurrPos);
    
    var sel = window.getSelection();
    /* https://javascript.info/selection-range#selecting-the-text-partially */
    // If node is a text node, then offset must be the position in its text.
    sel.collapse(currP.firstChild, lastCurrPos);
}

async function handleKeyPress(event) {
  currKey = event.code;
  console.log(`KeyboardEvent: key='${event.key}' | code='${event.code}'`);
  // console.log('currKey', currKey);

  switch(currKey) {
    case 'Slash':
      if (event.key != '/') { return; }
      event.preventDefault();
      playAndUpdateSub();
      break;

    case 'ControlLeft':
      await playCurrPos();
      resetTextAndPos();
      blinkCurPos();
      break;

    case 'AltLeft':
      event.preventDefault();
      if (ap.paused) { ap.currentTime -= 0.8; ap.play(); } else { ap.pause(); };
      break;

    case 'Enter':
      event.preventDefault();
      nextSub();
      break;

    case 'Tab':
      event.preventDefault();
      nextSub();
      break;

    case 'AltRight':
      event.preventDefault();
      adjust(+1);
      break;

    case 'OSRight':
      event.preventDefault();
      adjust(-1);
      break;

    case 'ArrowUp':
      break

    case 'ArrowDown':
      break

    case 'ArrowLeft':
      break

    case 'ArrowRight':
      break

    default:
      if (await loadTime(currSubIndex) != 0) { ap.pause(); }
  }
}

async function adjust(x) {
  let delta = await getCurrDelta();
  var time = await loadTime(currSubIndex) + delta;
  if (delta == 0 && lastCurrPos < 3) {
    time += 0.15 * x;
    saveTime(currSubIndex, time);
  } else {
    adjustDeltas(2 * x);
    time += 2 * x;
  }  
  ap.currentTime = time;
  ap.play();
  blinkCurPos();
}

function twoDigitsFormat(d) {
  return `${d <= 9 ? '0' : ''}${d}`
}

function secondsToTime(s) {
  let minutes = Math.floor(s / 60);
  s -= minutes*60;
  let seconds = Math.floor(s);
  let remains = s - seconds;
  remains = Math.round(remains * 100);
  return `${twoDigitsFormat(minutes)}:${twoDigitsFormat(seconds)}.${twoDigitsFormat(remains)}`
}/*
  secondsToTime(60)
*/

const pasteToCurrentEditableCursor = str => {
  document.execCommand('inserttext', false, str);
};


function nextSub() {
  if (currSubIndex < subsCount - 1) { 
    currSubIndex++;  
    document.getElementById(currSubIndex).focus();
  }
}

</script>
</html>
